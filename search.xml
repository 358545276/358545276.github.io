<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Http资源多线程下载]]></title>
    <url>%2Fposts%2F6d50677c%2F</url>
    <content type="text"><![CDATA[实现http资源多线程下载的小案例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169import java.io.IOException;import java.io.InputStream;import java.io.RandomAccessFile;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;public class MultiThreadDownload &#123; private String path; private int threadNum; public MultiThreadDownload(String path, int threadNum) &#123; this.path = path; this.threadNum = threadNum; &#125; public void startDownload() throws IOException &#123; URL url = new URL(path); HttpURLConnection conn =(HttpURLConnection)url.openConnection(); conn.setRequestMethod("GET"); conn.setConnectTimeout(5000); conn.connect(); if (conn.getResponseCode()==200)&#123; //1.获取要下载资源的大小。 int contentLength = conn.getContentLength(); //2.创建并设置同等大小的临时文件 RandomAccessFile raf = new RandomAccessFile("D:\\"+getFileName(),"rwd"); raf.setLength(contentLength); raf.close(); // 计算每个线程下载的大小，先不考虑有余数的情况 int block = contentLength / threadNum; for (int i = 0; i &lt; threadNum;i++)&#123; //计算线程下载的开始位置和结束位置 int startIndex = block * i; int endIndex = block * (i + 1) - 1; //解决有余数的情况。方法：直接写死最后一个线程的结束位置 if (i == threadNum-1)&#123; endIndex = contentLength-1; &#125; new DownThread(i,startIndex,endIndex).start(); &#125; &#125; &#125; private String getFileName() &#123; String fileName = path.substring(path.lastIndexOf("/") + 1); return fileName; &#125; //使用成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 class DownThread extends Thread&#123; private int ThreadId; private int start; private int end; public DownThread(int threadId, int start, int end) &#123; this.ThreadId = threadId; this.start = start; this.end = end; &#125; @Override public void run() &#123; super.run(); try &#123; //再次发送Http资源请求。 URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setRequestMethod("GET"); conn.setConnectTimeout(5000); conn.setDoInput(true); // Server通过请求头中的Range: bytes=0-xxx来判断是否是做Range请求， // 如果这个值存在而且有效，则只发回请求的那部分文件内容，响应的状态码变成206，表示Partial Content，并设置Content-Range。 // 如果无效，则返回416状态码，表明Request Range Not。 conn.setRequestProperty("Range","bytes="+start+"-"+end); conn.connect(); // 请求部分数据,响应码为206 if (conn.getResponseCode()== 206)&#123; InputStream in = conn.getInputStream(); RandomAccessFile raf = new RandomAccessFile("D:\\"+getFileName(),"rwd"); byte[] by = new byte[1024]; int len = 0; // 把文件的写入位置移动至start=startIndex raf.seek(start); while((len=in.read(by))!=-1)&#123; raf.write(by,0,len); &#125; raf.close(); in.close(); &#125;else &#123; System.out.println("部分资源请求失败！"); &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; new MultiThreadDownload("http://pic25.nipic.com/20121112/9252150_150552938000_2.jpg",4).startDownload(); &#125;&#125;]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决IDEA与Tomcat中文乱码问题]]></title>
    <url>%2Fposts%2F758f1330%2F</url>
    <content type="text"><![CDATA[Tomcat控制台乱码原因：​ Windows 的控制台默认是GBK编码的，而Toncat安装目录下的conf/logging.properties文件中的输出日志编码是UTF-8； 解决方法： 将Tom安装目录下的conf/logging.properties文件中的输出日志编码改为GBK; 只将Tomcat控制台的编码改为UTF-8 第一步：Windows+R打开运行，输入regedit进入注册表编辑器 第二步：在HKEY_CURRENT_USER→Console→Tomcat中修改CodePage为十进制的65001 注意：如果没有Tomcat或者CodePage，直接新建一个，如下图所示 也可以直接复制下面的代码，保存为.bat文件后，直接运行，即可修改成UTF-8。 12set rr="HKCU\Console\Tomcat"reg add %rr% /v "CodePage" /t REG_DWORD /d 0x0000fde9 /f&gt;nul IDEA控制台乱码解决乱码情况： 解决方法： ​ 进入Help→Edit custom VM options 打开idea64.exe.vmoptions文件追加 1-Dfile.encoding=UTF-8 重启IDEA]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程分割大文件]]></title>
    <url>%2Fposts%2F8acdd84%2F</url>
    <content type="text"><![CDATA[题目：使用4个子线程，把一个4G的大文件，拆分成8个文件（每个500M）。其中每个线程处理1G。重点:RandomAccessFile类，方法seek(long pos),read(byte[] b),write(byte[] b);123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;/** * 此类设计用于解决题目：使用4个子线程，把一个4G的大文件，拆分成8个文件（每个500M）。其中每个线程处理1G。 */public class SplitFile &#123; /** * 用于测试SplitFile类 * @param args */ public static void main(String[] args) &#123; SplitFile splitFile = new SplitFile(); //假设test.txt文件为4G,拆分成8个子文件 splitFile.splitFile("F:\\test.txt", 8); &#125; public void splitFile(String filePath, int childFileNum) &#123; File file = new File(filePath); /** * 根据文件个数创建线程数 2：1 */ for (int i = 0; i*2 &lt; childFileNum ; i++) &#123; new SplitThread(i, file, childFileNum).start(); &#125; &#125; /** * 此类为成员内部类，可访问外部类的属性和方法 */ class SplitThread extends Thread &#123; private int threadNo; private File file; private int childFileNum; private long block; private RandomAccessFile srcFile; //RandomAccessFile类常用于多线程分割文件，多线程下载 private File[] childFile = new File[2]; public SplitThread(int threadNo, File file, int childFileNum) &#123; this.threadNo = threadNo; this.file = file; this.childFileNum = childFileNum; /** * block的计算：即一个子文件的大小。若存在余数的情况则block++; */ block = file.length() / childFileNum; if (file.length() % childFileNum &gt; 0) &#123; block++; &#125; try &#123; srcFile = new RandomAccessFile(file, "rw"); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; /** * 一个线程需处理两个子文件，创建两个新文件。 */ for (int i = 0; i &lt; 2; i++) &#123; childFile[i] = new File(file.getParent(), (threadNo * 2 + i) + file.getName()); &#125; &#125; @Override public void run() &#123; try &#123; /** * 最重要的部分，RandomAccessFile类实现随机访问文件某段的函数。 * seek * public void seek(long pos) * throws IOException * 设置到此文件开头测量到的文件指针偏移量，在该位置发生下一个读取或写入操作。 * 偏移量的设置可能会超出文件末尾。 * 偏移量的设置超出文件末尾不会改变文件的长度。 * 只有在偏移量的设置超出文件末尾的情况下对文件进行写入才会更改其长度。 * 参数： * pos - 从文件开头以字节为单位测量的偏移量位置，在该位置设置文件指针。 * 抛出： * IOException - 如果 pos 小于 0 或者发生 I/O 错误。 */ srcFile.seek(threadNo * block * 2); for (int i = 0; i &lt; 2; i++) &#123; RandomAccessFile childFileW = new RandomAccessFile(childFile[i], "rw"); /** * 存在这样一种情况， * 当要写入的文件存在时，可能出现childFileW.length()&gt;=block； * 而无法满足下面的条件childFileW.length()&lt; block * 因此，使用这条语句直接将文件长度置为0，即清空文件。 * 当然也可已使用file对象的delete方法删除文件。 */ childFileW.setLength(0); byte[] by = new byte[1]; /** * 读一个写一个字节 * 注意：必须先判断写入的文件大小是否已写满，read判断在后。 * 否则，read判断在前，执行后，文件读取的指针会自动后移， * 若这时文件已写满，则会影响到下一个子文件前面少读了一段。 */ while (childFileW.length()&lt; block &amp;&amp; srcFile.read(by) != -1) &#123; childFileW.write(by); &#125; /** * 这个判断用来删除空文件，因为当要分成奇数个文件时，线程会多创建一个空文件， * 注意：删除前要先关闭此随机访问文件流并释放与该流关联的所有系统资源 */ if (childFile[i].length()==0)&#123; childFileW.close(); childFile[i].delete(); &#125; System.out.println(childFile[i].getCanonicalPath()+"\t"+childFile[i].length()); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 总结： 获取大文件对象srcFile。 根据给出的分割子文件数目，计算子文件大小block。 利用随机访问文件类的对象，设置指针即读取的开始位置，写入大小为block的子文件。 使用多线程和循环重复步骤3，直到文件写完。]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis自动部署Hexo博客]]></title>
    <url>%2Fposts%2F8d89dae9%2F</url>
    <content type="text"><![CDATA[1.Github中创建存储Hexo博客项目源码的仓库（空仓）2.使用Github账户登录Travis3.选择并激活存储Hexo博客项目源码的仓库4.在Github账户settings-&gt;developer setting-&gt;Personal access tokes 生成token 5.配置Travis的环境变量 6.在Hexo博客根目录下添加.travis.yml配置文件123456789101112131415161718192021222324252627282930313233343536373839language: node_js # 设置语言node_js: stable # 设置相应版本cache: directories: - node_modules # 设置缓存，会在构建的时候快一些# before_install: # - npm install hexo-cli -ginstall: - npm install # 安装hexo及插件 #- npm install -g gulp script: - hexo clean # 清除 - hexo g # 生成 after_script: - cd public - git init - git config user.name "fangchieh" - git config user.email "358545276@qq.com" - git add . - git commit -am "Travis CI Auto Builder :$(date '+%Y-%m-%d %H:%M:%S' -d '+8 hour')" - git push -f $&#123;GH_REF&#125; master - git push -f $&#123;CODING&#125; master branches: only: - master #只监测master分支,这是我自己的博客，所以就用的master分支了。env: global: - GH_REF: https://fangchieh:$&#123;travis&#125;@github.com/fangchieh/fangchieh.github.io.git #设置GH_REF，注意更改yourname,travis:就是我们在travis-ci仓库中配置的环境变量 - CODING: https://fangchieh:$&#123;coding_travis&#125;@git.dev.tencent.com/fangchieh/fangchieh.coding.me.git 7.在本地提交.travis.yml更新后，将整个博客项目push到新建的GitHub空仓注意：必须先将博客项目初始化git项目 123456cd myblog (博客根目录)git init . (初始化成git项目)git add . (将所有博客文件添加到暂存区并跟踪)git commit -m "描述" (提交暂存区的文件到版本库)git remote add origin git@github.com/youname/空仓名称.git (为本地git项目添加远程仓库地址)git push -u origin master （将本地项目推送到远程仓库的master主分支） 8.当travis检测到源码仓库有push时，就会自动构建（build）]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo建立个人博客]]></title>
    <url>%2Fposts%2F92d7f61f%2F</url>
    <content type="text"><![CDATA[1. Windows下安装HexoHexo安装前需要环境: Git Node.js 安装完成后，即在git bash可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml 网站的配置信息├── package.json 应用程序的信息├── scaffolds 模版文件夹├── source 存放用户资源| ├── _drafts | └── _posts└── themes 主题文件夹。Hexo 会根据主题来生成静态页面。 1$ hexo server 打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。 2. Github账户注册和新建项目 注册Github账户 新建项目,项目名必须要遵守格式：账户名.github.io 在项目 “账户名.github.io” 的设置 (Settings)里开启 GitHub Pages 服务 3. 生成SSH添加到GitHub 设置Git的user name和email 12$ git config --global user.name "Github用户名"$ git config --global user.email "Github邮箱" 生成SSH密钥 一路回车即可 1$ ssh-keygen -t rsa -C "Github邮箱" 将id_rsa.pub里面的信息复制到Github的SSH keys 在gitbash中，查看是否成功 1$ ssh -T git@github.com 4. 将hexo部署到GitHub 打开站点配置文件 _config.yml ,设置为 1234deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.gitbranch: master 安装deploy-git 1$ npm install hexo-deployer-git --save 部署到Github Page 12345$ hexo clean 清除了之前生成的文件，也可不加$ hexo generate 生成静态文章，可以用 hexo g 缩写$ hexo deploy 部署文章，可以用 hexo d 缩写或$ hexo clean&amp;&amp;hexo g&amp;&amp;hexo d 三个命令依序一次执行 注意: deploy时可能要你输入username和password。 得到下图就说明部署成功了，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了！！! 5. 设置个人域名 申请免费域名(钱多的可撒币) 在freenom注册登录即可申请多个免费域名(有效期一年,可免费续期) 在DNSPod中添加域名解析 (下面的步骤注意替换) 将解析后的两条NS记录加入到 freenom Nameservers 在DNSPod中为你的域名添加记录 注意: 记录类型必须是CNAME类型 : 将域名指向另一个域名，再由另一个域名提供ip地址 其中 主机记录为 @ 则直接指向 fangchieh.ml xxx 则 指向 xxx.fangchieh.ml 根据记录添加CNAME文件 添加位置: 博客根文件夹下的source下 添加文件名为 CNAME (名字必须一致,无文件扩展名) 添加内容: fangchieh.ml (主机记录为 @ ) xxx.fangchieh.ml (主机记录为 xxx ) 最后，在gitbash中重新部署到Github，输入 1$ hexo clean&amp;&amp;hexo g&amp;&amp;hexo d 过不了多久，在浏览器中，输入你自己的域名，就可以看到搭建的网站啦！]]></content>
      <tags>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2Fposts%2Fd87f7e0c%2F</url>
    <content type="text"><![CDATA[这是一个测试博客]]></content>
      <tags>
        <tag>实例</tag>
      </tags>
  </entry>
</search>
